{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;;;;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA,IAAI;AACJ;AACA;AACA;AACA;;;;AAIO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;;;;;;;UC5FA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACJiF;;AAEjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,sCAAsC,gCAAgC;AACtE;AACA;;AAEA,2BAA2B,iEAAiB;AAC5C,2BAA2B,6DAAa;AACxC,4BAA4B,8DAAc;AAC1C;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gBAAgB;AAChB,uC","sources":["webpack://toyproject/./transcript.js","webpack://toyproject/webpack/bootstrap","webpack://toyproject/webpack/runtime/define property getters","webpack://toyproject/webpack/runtime/hasOwnProperty shorthand","webpack://toyproject/webpack/runtime/make namespace object","webpack://toyproject/./inject.js"],"sourcesContent":["\nexport async function getVideoFormat() {\n  try {\n    const url = window.location.href;\n    const videoPageResponse = await fetch(url);\n    const videoPageHtml = await videoPageResponse.text();\n    const splittedHtml = videoPageHtml.split('\"microformat\":');\n\n    if (splittedHtml.length < 2) {\n      return; // No Caption Available\n    }\n\n    const videoFormat_json = JSON.parse(splittedHtml[1].split(',\"cards\"')[0].replace('\\n', ''))\n    console.log(videoFormat_json)\n    const titleName = videoFormat_json.playerMicroformatRenderer.title.simpleText;\n    const thumbnail = videoFormat_json.playerMicroformatRenderer.thumbnail.thumbnails[0].url;\n\n    return {\n      title : titleName,\n      thumbnail_url : thumbnail\n    }\n\n\n  } catch (error) {\n    console.error(error);\n    return;\n  }\n}\n\n\n\nexport async function getLangTranscript() {\n  try {\n    const url = window.location.href;\n    const videoPageResponse = await fetch(url);\n    const videoPageHtml = await videoPageResponse.text();\n    const splittedHtml = videoPageHtml.split('\"captions\":');\n\n    if (splittedHtml.length < 2) {\n      return; // No Caption Available\n    }\n\n    const captions_json = JSON.parse(splittedHtml[1].split(',\"videoDetails')[0].replace('\\n', ''));\n    console.log(videoPageHtml)\n    const captionTracks = captions_json.playerCaptionsTracklistRenderer.captionTracks;\n    const languageOptions = Array.from(captionTracks).map(i => i.name.simpleText);\n\n    const first = \"Korean\"; \n    languageOptions.sort((x, y) => x.includes(first) ? -1 : y.includes(first) ? 1 : 0);\n    languageOptions.sort((x, y) => x === first ? -1 : y === first ? 1 : 0);\n\n    return Array.from(languageOptions).map((langName, index) => {\n      const link = captionTracks.find(i => i.name.simpleText === langName).baseUrl;\n      return {\n        language: langName,\n        link: link\n      };\n    });\n  } catch (error) {\n    console.error(error);\n    return;\n  }\n}\n\nexport async function getTranscript(langOption) {\n  try {\n    const rawTranscript = await getRawTranscript(langOption.link);\n    const transcript = rawTranscript.map(item => item.text).join(' ');\n    return transcript;\n  } catch (error) {\n    console.error(error);\n    return;\n  }\n}\n\nexport async function getRawTranscript(link) {\n  try {\n    const transcriptPageResponse = await fetch(link);\n    const transcriptPageText = await transcriptPageResponse.text();\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(transcriptPageText, \"text/xml\");\n    const textNodes = doc.getElementsByTagName(\"text\");\n\n    return Array.from(textNodes).map(i => ({\n      start: i.getAttribute(\"start\"),\n      duration: i.getAttribute(\"dur\"),\n      text: i.textContent\n    }));\n  } catch (error) {\n    console.error(error);\n    return;\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\n\nimport {getLangTranscript, getTranscript, getVideoFormat } from \"./transcript.js\"\n\nfunction addElement (container) {\n  var hi_button = document.createElement('div');\n  hi_button.setAttribute(\"id\", \"yt-summery-side-bar\");\n  hi_button.style.backgroundColor = 'white';\n  hi_button.style.height = '50px'\n  hi_button.innerHTML = '<b>Youtube AI</b>';\n  container.prepend(hi_button);\n}\n\nasync function run_script() {\n\n  const observer = new MutationObserver((mutationsList, observer) => {\n    for(let mutation of mutationsList) {\n      if (mutation.type === 'childList') {\n        let container = document.getElementById(\"secondary-inner\");\n        if (container) {\n          addElement(container);\n          observer.disconnect();\n          break;\n        }\n      }\n    }\n  });\n\n  const sideBar = document.getElementById('yt-summery-side-bar');\n  if(!sideBar){\n    observer.observe(document.body, { childList: true, subtree: true });\n  }\n  \n\n  const langOption = await getLangTranscript();\n  const transcript = await getTranscript(langOption[0]);\n  const videoFormat = await getVideoFormat()\n  console.log(videoFormat);\n  console.log(transcript);\n}\n\n\nlet previousUrl = '';\nconst observer_url = new MutationObserver(function(mutations) {\n  if (location.href !== previousUrl) {\n      previousUrl = location.href;\n      run_script();\n    }\n});\nconst config = {subtree: true, childList: true};\nobserver_url.observe(document, config);"],"names":[],"sourceRoot":""}